프로젝트 기획 요약
1. 프로젝트 목표 AI Claude를 활용하여 개인 학습 계획을 수립하고 진행 상황을 Notion DB와 연동하여 관리하는 자동화 시스템 구축
2. 시스템 구성 요소1.  AI 모델: Claude Desktop, MCP (Model Context Protocol) 서버: 사용자 정의 서버
3. Notion: 학습 계획 및 진행 상황 관리 DB

3. MCP 서버 역할 Claude Desktop과 Notion DB 간의 통신 중개 Claude Desktop으로부터 
학습 계획 및 피드백 요청 수신 Notion API를 호출하여 DB 업데이트 및 정보 조회
커밋 이벤트 감지 및 학습 내용 요약 후 Notion에 기록
4. 학습 계획 수립 및 Notion DB 구조
대화형 계획 수립  Claude 대화를 통해 학습 목표 및 계획 구체화

 5. 학습 내용 기록 및 요약 
자동화1.  **트리거:** Git 커밋 발생
2.  정보 추출: 커밋 내용의 주석에서 정규 표현식을 사용하여 코드 블록 및 특정 정보 추출
3.  MCP 서버:    * 커밋 이벤트 감지    * 커밋 내용 파싱 및 관련 정보 추출    * Notion API를 사용하여 해당 커밋 날짜의 페이지 검색 (날짜 속성 활용)    
* AI (Claude/Cursor API) 호출하여 학습 내용 요약 요청    
* Notion API를 사용하여 해당 페이지의 "AI 요약" 블록 업데이트 (블록 ID 저장 방식 고려)
### 6. 학습 진행 상황 관리 및 피드백* 사용자가 Notion DB에서 "진행 상태" 및 "복습 상태" 업데이트* (구체적인 트리거 조건은 추후 결정) 
MCP 서버가 Notion DB 업데이트 감지* Claude에게 학습 목표, 진행 상황 등 정보 전달하여 피드백 요청* Claude/Cursor로부터 받은 피드백을 Notion 페이지에 기록

7. 기술적 고려 사항* MCP 서버와 Claude Desktop 간 JSON 기반 통신
*Notion API 키는 환경 변수로 관리* 
Notion API의 데이터베이스 쿼리 (`/v1/databases/{database_id}/query`) 활용 
(날짜 속성 기반 검색)* Notion API를 이용한 
페이지 생성 및 블록 업데이트 (`/v1/pages`, `/v1/blocks`) 활용* 
"AI 요약" 블록 ID 저장 및 활용 (Notion DB 속성 또는 별도 저장소)* 커밋 내용 파싱을 위한 정규 표현식 활용

-- learning_databases

id	db_id	title	parent_page_id	created_at	status	last_used_date	updated_at
b1e36225-bc4e-48ae-90b2-f8928d488c34	1d415ba8-df0e-8182-bf86-ca34bcce11a5	React 학습 계획	15415ba8-df0e-80e4-83e4-bcf738689aecc	2025-04-22 03:43:27.149678+00	ready	2025-04-24	2025-04-24 03:16:10.784861+00

-- 상태값(대기중 사용중 끝)
alter table learning_databases
add column status text default 'ready' check (status in ('ready', 'used', 'end'));

-- 마지막 사용일 컬럼 추가
alter table learning_databases
add column last_used_date date default current_date;

-- 갱신일시 컬럼 추가
alter table learning_databases
add column updated_at timestamp with time zone default now();



-- learning_pages
create table public.learning_pages (
  id uuid primary key default gen_random_uuid(),
  date date not null,
  title text not null,
  page_id text not null,
  ai_block_id text not null,
  learning_db_id uuid references public.learning_databases(id) on delete cascade,
  created_at timestamp with time zone default now()
);

-- 인덱스 추가
create index idx_learning_pages_date on public.learning_pages (date);
create index idx_learning_pages_title on public.learning_pages (title);

create table public.learning_pages (
  id uuid primary key default gen_random_uuid(),
  date date not null,
  title text not null,
  page_id text not null,
  ai_block_id text not null,
  learning_db_id uuid references public.learning_databases(id) on delete cascade,
  created_at timestamp with time zone default now()
);

-- 인덱스 추가
create index idx_learning_pages_date on public.learning_pages (date);
create index idx_learning_pages_title on public.learning_pages (title);

commit

select * from learning_databases

-- 상태값(대기중 사용중 끝)
alter table learning_databases
add column status text default 'ready' check (status in ('ready', 'used', 'end'));

-- 마지막 사용일 컬럼 추가
alter table learning_databases
add column last_used_date date default current_date;

-- 갱신일시 컬럼 추가
alter table learning_databases
add column updated_at timestamp with time zone default now();

select * from learning_pages

alter table webhook_operations enable row level security;


ALTER TABLE learning_databases
ADD COLUMN webhook_id text,
ADD COLUMN webhook_status text DEFAULT 'inactive';


CREATE TABLE public.webhook_operations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  db_id TEXT NOT NULL,
  operation_type TEXT NOT NULL CHECK (operation_type IN ('create', 'delete', 'verify', 'restore')),
  status TEXT NOT NULL CHECK (status IN ('pending', 'success', 'failed', 'retry')),
  error_message TEXT,
  retry_count INT DEFAULT 0,
  webhook_id TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

-- 인덱스 추가
CREATE INDEX idx_webhook_operations_db_id ON public.webhook_operations (db_id);
CREATE INDEX idx_webhook_operations_status ON public.webhook_operations (status);
CREATE INDEX idx_webhook_operations_created_at ON public.webhook_operations (created_at);


-- webhook_status에 CHECK 제약 추가 (아직 없다면)
ALTER TABLE learning_databases 
ADD CONSTRAINT check_webhook_status 
CHECK (webhook_status IN ('active', 'inactive', 'error'));

-- 마지막 검증 시간 추가 (웹훅 상태 확인용)
ALTER TABLE learning_databases
ADD COLUMN last_webhook_check TIMESTAMP WITH TIME ZONE;

-- 웹훅 생성/확인 시 발생한 오류 메시지 저장
ALTER TABLE learning_databases
ADD COLUMN webhook_error TEXT;

-- webhook_id에 인덱스 추가 (빠른 조회용)
CREATE INDEX idx_learning_databases_webhook_id ON public.learning_databases (webhook_id);

-- webhook_status에 인덱스 추가
CREATE INDEX idx_learning_databases_webhook_status ON public.learning_databases (webhook_status);


6단계: Make.com 시나리오 구현
시나리오 1: 웹훅 생성 (WEBHOOK_CREATE_URL에 해당)
HTTP 웹훅 트리거:
수신된 데이터에서 db_id 추출
HTTP 요청 - DB 정보 가져오기:
Method: GET
URL: https://exit-land-nyc-exceptional.trycloudflare.com/get_db/{{1.body.db_id}}
Notion 웹훅 생성:
Notion 앱 모듈 선택
"Watch Events in a Database" 트리거 생성
DB ID 설정: {{1.body.db_id}}
트리거 설정 완료 후 생성된 웹훅 ID 저장
HTTP 요청 - 웹훅 정보 업데이트:
Method: POST
URL: https://exit-land-nyc-exceptional.trycloudflare.com/update_webhook
Body:
  {
    "db_id": "{{1.body.db_id}}",
    "webhook_id": "{{3.webhook_id}}",
    "webhook_status": "active"
  }
시나리오 2: Notion DB 감시 (웹훅 생성 시나리오에서 설정)
Notion 데이터베이스 이벤트 트리거:
DB ID: 웹훅 생성 시 지정된 ID
이벤트 유형: 페이지 생성, 수정, 삭제
데이터 변환:
상태 매핑 함수 정의
function mapStatus(notionStatus) {
  switch(notionStatus) {
    case "시작 전": return "not-started";
    case "진행중": return "in-progress";
    case "완료": return "completed";
    default: return "unknown";
  }
}
HTTP 요청 - Supabase 데이터 업데이트:
Method: PATCH
URL: https://gawybycxbfvfahjsxaaj.supabase.co/rest/v1/learning_pages
Headers: [API 키 및 인증 정보]
Query: page_id=eq.{{1.page_id}}
Body:
  {
    "title": "{{1.properties.학습_제목.title[0].plain_text}}",
    "status": "{{mapStatus(1.properties.진행_상태.select.name)}}"
  }
시나리오 3: 웹훅 삭제 (WEBHOOK_DELETE_URL에 해당)
HTTP 웹훅 트리거:
수신된 데이터에서 db_id 추출
HTTP 요청 - 웹훅 정보 가져오기:
Method: GET
URL: https://exit-land-nyc-exceptional.trycloudflare.com/get_webhook/{{1.body.db_id}}
웹훅 삭제:
조건: webhook_id가 비어있지 않은 경우
Notion 앱 모듈에서 웹훅 비활성화 (Disable Trigger)
웹훅 ID: {{2.webhook_id}}
HTTP 요청 - 웹훅 정보 업데이트:
Method: POST
URL: https://exit-land-nyc-exceptional.trycloudflare.com/update_webhook
Body:
  {
    "db_id": "{{1.body.db_id}}",
    "webhook_id": "",
    "webhook_status": "inactive"
  }
7단계: 테스트 및 검증
Supabase 테이블 확장 확인
각 모듈 배포:
supa.py 함수 확장
notion_qry.py 함수 확장
main.py API 엔드포인트 업데이트
mcpserver.py MCP 도구 업데이트
Make.com 시나리오 구현:
웹훅 생성 시나리오
DB 감시 시나리오
웹훅 삭제 시나리오
통합 테스트:
MCP 명령 -> FastAPI -> Make.com -> Notion 흐름 확인
변경 감지 및 처리 확인
이제 이 구현 계획을 따라 각 파일을 책임에 맞게 깔끔하게 분리하여 구현할 수 있습니다. 각 파일은 자신의 역할만 충실히 수행하고, 다른 기능은 해당 기능을 담당하는 모듈에 위임합니다.

이 방식의 장점:

유지보수성 향상: 각 모듈이 명확한 책임을 가짐
테스트 용이성: 모듈별로 독립적인 테스트 가능
확장성: 새로운 기능 추가 시 적절한 모듈에만 집중할 수 있음
코드 가독성: 논리적으로 관련된 기능이 함께 위치